<?php

namespace SPGame\Game\Services;

use SPGame\Core\Logger;
use SPGame\Core\Message;
use SPGame\Core\WSocket;

use SPGame\Game\Repositories\Accounts;
use SPGame\Game\Repositories\Builds;
use SPGame\Game\Repositories\Techs;

use SPGame\Game\Repositories\Planets;
use SPGame\Game\Repositories\Users;
use SPGame\Game\Repositories\Config;
use SPGame\Game\Repositories\Resources;

use SPGame\Game\Repositories\Queues;

use SPGame\Game\Repositories\Vars;

use SPGame\Game\Repositories\PlayerQueue;

use Swoole\Timer;

class EventLoop
{
    protected Logger $logger;

    private array $tasks = [];

    public function __construct()
    {
        $this->logger = Logger::getInstance();
    }


    public function register(callable $callback, int $intervalMs): void
    {
        $this->tasks[] = [
            'interval' => $intervalMs,
            'callback' => $callback
        ];
    }

    /**
     * Запуск игрового цикла через Swoole Timer
     * @param int $interval Интервал в миллисекундах
     */
    public function start(): void
    {

        foreach ($this->tasks as $task) {
            $this->logger->info("Event loop started with interval {$task['interval']}ms");
            Timer::tick($task['interval'], $task['callback']);
        }

        /*Timer::tick($interval, function () {
            $this->process();
        });*/
    }

    /**
     * Основная логика обработки
     */
    public function process(): void
    {
        $StatTimeTick = microtime(true);

        foreach (Accounts::getOnline() as $Account) {

            $sendMsg = false;

            $AccountData = [
                'Account' => $Account,
                'User' => Users::findByAccount($Account['id'])
            ];
            if (!$AccountData['User']) continue;



            
            $Planets = Planets::getAllPlanets($AccountData['User']['id']);


            foreach ($Planets as $planetId => $Planet) {

                $AccountData['Planet'] = $Planet;
                $AccountData['Builds'] = Builds::findById($Planet['id']);
                $AccountData['Techs'] = Techs::findById($AccountData['User']['id']);
                $AccountData['Resources'] = Resources::get($AccountData);


                $sendMsg = ($this->processPlanet($StatTimeTick, $AccountData)) ? true : $sendMsg;


                Resources::updateByPlanetId($AccountData['Planet']['id'], $AccountData['Resources']);
                Planets::update($AccountData['Planet']);
                Builds::update($AccountData['Builds']);
                Techs::update($AccountData['Techs']);
                Users::update($AccountData['User']);
            }

            $sendMsg = ($this->processPlayerEvents($Account['id'])) ? true : $sendMsg;

            //Logger::getInstance()->info("ProcessPlayerEvents sendMsg " . (($sendMsg)?"true":"false") . " ");

            if ($sendMsg) {
                self::sendActualData($Account['id']);
            }
            //Users::update($User);
        }
        // Можно логировать, если нужно
        $duration = round(microtime(true) - $StatTimeTick, 3);
        $this->logger->debug("Event process time: {$duration}s");
    }

    protected function processPlanet(float $StatTime, array &$AccountData): bool
    {
        $sendMsg = false;

        // Обновление очереди строек/технологий
        $sendMsg = ($this->processQueues($StatTime, $AccountData)) ? true : $sendMsg;

        // Обновление ресурсов на планетах
        $this->processResources($StatTime, $AccountData);

        return $sendMsg;
    }

    protected function processResources(float $StatTimeTick, array &$AccountData): void
    {
        if ($AccountData['Planet']['update_time'] < $AccountData['Planet']['create_time']) {
            $AccountData['Planet']['update_time'] = $AccountData['Planet']['create_time'];
        }

        $ProductionTime = ($StatTimeTick - $AccountData['Planet']['update_time']);

        if ($ProductionTime > 0) {
            $AccountData['Planet']['update_time'] = $StatTimeTick;
            $Resources = &$AccountData['Resources'];

            //if ($Planets[$PID]['PlanetType'] == 3)
            //    return;

            foreach (Vars::$reslist['resstype'][1] as $ResID) {
                $Theoretical = $ProductionTime * ($Resources[$ResID]['perhour']) / 3600;
                if ($Theoretical < 0) {
                    $Resources[$ResID]['count'] = max($Resources[$ResID]['count'] + $Theoretical, 0);
                } elseif ($Resources[$ResID]['count'] <= $Resources[$ResID]['max']) {
                    $Resources[$ResID]['count'] = min($Resources[$ResID]['count'] + $Theoretical, $Resources[$ResID]['max']);
                }
                $Resources[$ResID]['count'] = max($Resources[$ResID]['count'], 0);
            }

            //Resources::updateByPlanetId($AccountData['Planet']['id'], $Resources);
        }
    }

    protected function processQueues(float $StatTimeTick, array &$AccountData): bool
    {

        $sendMsg = false;
        // Лимит для защиты от бесконечного цикла
        $maxIterations = 50;
        while ($maxIterations-- > 0) {
            $Queue = Queues::getActiveMinEndTime($AccountData['Planet']['id']);
            if (!$Queue) {
                // Нет активных очередей — выходим
                break;
            }
            if ($Queue['end_time'] > $StatTimeTick) {
                // Прервать цикл
                break;
            }

            $this->logger->info(
                sprintf(
                    "Queue complete: id=%d, type=%s, planet=%d, end=%.3f <= %.3f",
                    $Queue['id'],
                    $Queue['type'] ?? '?',
                    $Queue['planet_id'],
                    $Queue['end_time'],
                    $StatTimeTick
                )
            );

            // 1️⃣ Пересчитываем ресурсы до момента окончания постройки
            $this->processResources($Queue['end_time'], $AccountData);

            // 2️⃣ Завершаем постройку (увеличиваем уровень, снимаем блокировку и т.д.)
            QueuesServices::CompleteQueue(
                $Queue['id'],
                $AccountData,
                $Queue['end_time']
            );

            /*
            // 3️⃣ Пересчитываем все очереди с учетом новой скорости/уровней
            QueuesServices::ReCalcTimeQueue(
                $Queue['type'],
                $AccountData,
                $Queue['end_time']
            );
            */

            if (
                $Queue['planet_id'] == $AccountData['User']['current_planet'] ||
                ($Queue['type'] == QueuesServices::TECHS && $Queue['user_id'] == $AccountData['User']['id'])

            ) {
                $sendMsg = true;
            }
        }


        return $sendMsg;
        // Пример: обработка очередей строек или технологий
        // QueueWorker::tick();
    }

    /**
     * Обработка очереди событий игроков
     */
    protected function processPlayerEvents(int $accountId): bool
    {

        $sendMsg  = false;
        $Queues = PlayerQueue::getByAccaunt($accountId) ?? [];

        foreach ($Queues as $Event) {

            $AccountData = [
                'Account'   => Accounts::findById($Event['account_id']),
                'User'      => Users::findById($Event['user_id']),
                'Planet'    => Planets::findById($Event['planet_id']),
                'Builds'    => Builds::findById($Event['planet_id']),
                'Techs'     => Techs::findById($Event['user_id'])
            ];
            $AccountData['Resources']   = Resources::get($AccountData);


            switch ($Event['action']) {
                case PlayerQueue::ActionQueueUpgarde:
                    QueuesServices::AddToQueue($Event['data']['Element'], $AccountData, $Event['added_at'], true);
                    $sendMsg  = true;
                    break;

                case PlayerQueue::ActionQueueDismantle:
                    QueuesServices::AddToQueue($Event['data']['Element'], $AccountData, $Event['added_at'], false);
                    $sendMsg  = true;
                    break;

                case PlayerQueue::ActionQueueCancel:
                    QueuesServices::CancelToQueue($Event['data']['QueueId'], $AccountData, $Event['added_at']);
                    $sendMsg  = true;
                    break;

                case PlayerQueue::ActionQueueReCalcTech:
                    Logger::getInstance()->info("PlayerQueue::ActionQueueReCalcTech");
                    QueuesServices::ReCalcTimeQueue(QueuesServices::TECHS, $AccountData, $Event['added_at']);
                    $sendMsg  = true;
                    break;

                    // можно добавить другие действия
            }

            Resources::updateByPlanetId($AccountData['Planet']['id'], $AccountData['Resources']);
            Planets::update($AccountData['Planet']);
            Builds::update($AccountData['Builds']);
            Techs::update($AccountData['Techs']);
            Users::update($AccountData['User']);

            Logger::getInstance()->info("ProcessPlayerEvents " . $Event['action']);

            PlayerQueue::delete($Event);
        }

        return $sendMsg;
        /*if ($sendMsg) {
            self::sendActualData($accountId);
        }*/
    }

    protected function sendActualData(int $accountId): void
    {
        $Account = Accounts::findById($accountId);
        if (!$Account) {
            $this->logger->warning("sendActualData: account not found", ['accountId' => $accountId]);
            return;
        }

        $frame = (int)$Account['frame'];
        if ($frame < 1) {
            $this->logger->warning("sendActualData: invalid frame for account", ['accountId' => $accountId, 'frame' => $frame]);
            return;
        }

        $ws = WSocket::getInstance();
        if (!$ws) {
            $this->logger->error("sendActualData: WebSocket instance not available", ['accountId' => $accountId]);
            return;
        }

        $response = new Message();
        $response->setMode($Account['mode']);
        $response->setAction("ActualData");

        $this->logger->info("sendActualData: sending to account", ['accountId' => $accountId, 'mode' => $Account['mode'], 'frame' => $frame]);

        $pageBuilder = new \SPGame\Game\PageBuilder($response, $frame);
        $response = $pageBuilder->build($response);

        $ws->Send($frame, $response);
    }
}
